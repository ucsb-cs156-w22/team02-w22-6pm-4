"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformBabel = void 0;
const core_1 = require("@babel/core");
/* eslint-disable @typescript-eslint/no-duplicate-imports */
// @ts-expect-error The babel types don't define "File" yet
const core_2 = require("@babel/core");
/* eslint-enable @typescript-eslint/no-duplicate-imports */
const mutant_placers_1 = require("../mutant-placers");
const mutators_1 = require("../mutators");
const syntax_helpers_1 = require("../util/syntax-helpers");
const transformBabel = ({ root, originFileName, rawContent, offset }, mutantCollector, { options }) => {
    var _a, _b;
    // Wrap the AST in a `new File`, so `nodePath.buildCodeFrameError` works
    // https://github.com/babel/babel/issues/11889
    const file = new core_2.File({ filename: originFileName }, { code: rawContent, ast: root });
    // Range filters that are in scope for the current file
    const mutantRangesForCurrentFile = options.mutationRanges.filter((mutantRange) => mutantRange.fileName === originFileName);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    core_1.traverse(file.ast, {
        enter(path) {
            // Don't mutate import statements, type definitions and nodes that don't have overlap with the current range filter
            if (syntax_helpers_1.isTypeNode(path) ||
                syntax_helpers_1.isImportDeclaration(path) ||
                path.isDecorator() ||
                (mutantRangesForCurrentFile.length && mutantRangesForCurrentFile.every((range) => !syntax_helpers_1.locationOverlaps(range, path.node.loc)))) {
                path.skip();
            }
            else if (!mutantRangesForCurrentFile.length || mutantRangesForCurrentFile.some((range) => syntax_helpers_1.locationIncluded(range, path.node.loc))) {
                mutators_1.mutate(path, options).forEach((mutant) => {
                    mutantCollector.add(originFileName, mutant, offset === null || offset === void 0 ? void 0 : offset.position, offset === null || offset === void 0 ? void 0 : offset.line);
                });
            }
        },
        exit(path) {
            const mutants = mutantCollector.findUnplacedMutantsInScope(path.node);
            if (mutant_placers_1.placeMutants(path, mutants, originFileName)) {
                path.skip();
                mutantCollector.markMutantsAsPlaced(mutants);
            }
        },
    });
    if (mutantCollector.hasPlacedMutants(originFileName)) {
        // Be sure to leave comments like `// @flow` in.
        let header = syntax_helpers_1.instrumentationBabelHeader;
        if (Array.isArray((_a = root.program.body[0]) === null || _a === void 0 ? void 0 : _a.leadingComments)) {
            header = [
                Object.assign(Object.assign({}, syntax_helpers_1.instrumentationBabelHeader[0]), { leadingComments: (_b = root.program.body[0]) === null || _b === void 0 ? void 0 : _b.leadingComments }),
                ...syntax_helpers_1.instrumentationBabelHeader.slice(1),
            ];
        }
        root.program.body.unshift(...header);
    }
};
exports.transformBabel = transformBabel;
//# sourceMappingURL=babel-transformer.js.map