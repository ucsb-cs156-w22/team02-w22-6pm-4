"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutantCollector = void 0;
const mutant_1 = require("../mutant");
class MutantCollector {
    constructor() {
        this._mutants = [];
        this.unplacedMutants = [];
    }
    get mutants() {
        return this._mutants;
    }
    /**
     * Adds a mutant to the internal mutant list.
     * @param fileName file name that houses the mutant
     * @param mutationSpecs the named node mutation to be added
     * @param positionOffset position offset of mutant node
     * @param lineOffset line offset of mutant node
     * @returns The mutant (for testability)
     */
    add(fileName, mutationSpecs, positionOffset = 0, lineOffset = 0) {
        mutationSpecs.replacement.end = mutationSpecs.original.end;
        mutationSpecs.replacement.start = mutationSpecs.original.start;
        mutationSpecs.replacement.loc = mutationSpecs.original.loc;
        const mutant = new mutant_1.Mutant(this._mutants.length, fileName, mutationSpecs, positionOffset, lineOffset);
        this._mutants.push(mutant);
        if (mutant.ignoreReason === undefined) {
            // Only place mutants that are not ignored
            this.unplacedMutants.push(mutant);
        }
        return mutant;
    }
    findUnplacedMutantsInScope(scope) {
        return this.unplacedMutants.filter((mutant) => scope.start <= mutant.replacement.start && scope.end >= mutant.replacement.end);
    }
    markMutantsAsPlaced(mutants) {
        this.unplacedMutants = this.unplacedMutants.filter((unplaced) => !mutants.includes(unplaced));
    }
    hasPlacedMutants(fileName) {
        const unplacedMutants = this.unplacedMutants.filter((mutant) => mutant.fileName === fileName);
        return this.mutants.some((mutant) => !unplacedMutants.includes(mutant) && mutant.fileName === fileName);
    }
}
exports.MutantCollector = MutantCollector;
//# sourceMappingURL=mutant-collector.js.map