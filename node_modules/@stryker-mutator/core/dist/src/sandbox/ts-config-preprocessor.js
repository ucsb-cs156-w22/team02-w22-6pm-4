"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TSConfigPreprocessor = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
/**
 * A helper class that rewrites `references` and `extends` file paths if they end up falling outside of the sandbox.
 * @example
 * {
 *   "extends": "../../tsconfig.settings.json",
 *   "references": {
 *      "path": "../model"
 *   }
 * }
 * becomes:
 * {
 *   "extends": "../../../../tsconfig.settings.json",
 *   "references": {
 *      "path": "../../../model"
 *   }
 * }
 */
class TSConfigPreprocessor {
    constructor(log, options) {
        this.log = log;
        this.options = options;
        this.touched = [];
        this.fs = new Map();
    }
    async preprocess(input) {
        if (this.options.inPlace) {
            // If stryker is running 'inPlace', we don't have to change the tsconfig file
            return input;
        }
        else {
            const tsconfigFile = path_1.default.resolve(this.options.tsconfigFile);
            if (input.find((file) => file.name === tsconfigFile)) {
                this.fs.clear();
                input.forEach((file) => {
                    this.fs.set(file.name, file);
                });
                await this.rewriteTSConfigFile(tsconfigFile);
                return [...this.fs.values()];
            }
            else {
                return input;
            }
        }
    }
    async rewriteTSConfigFile(tsconfigFileName) {
        if (!this.touched.includes(tsconfigFileName)) {
            this.touched.push(tsconfigFileName);
            const tsconfigFile = this.fs.get(tsconfigFileName);
            if (tsconfigFile) {
                this.log.debug('Rewriting file %s', tsconfigFile);
                const ts = await Promise.resolve().then(() => tslib_1.__importStar(require('typescript')));
                const { config } = ts.parseConfigFileTextToJson(tsconfigFile.name, tsconfigFile.textContent);
                if (config) {
                    await this.rewriteExtends(config, tsconfigFileName);
                    await this.rewriteProjectReferences(config, tsconfigFileName);
                    this.fs.set(tsconfigFileName, new core_1.File(tsconfigFileName, JSON.stringify(config, null, 2)));
                }
            }
        }
    }
    async rewriteExtends(config, tsconfigFileName) {
        const extend = config.extends;
        if (typeof extend === 'string') {
            const extendsFileName = path_1.default.resolve(path_1.default.dirname(tsconfigFileName), extend);
            const relativeToSandbox = path_1.default.relative(process.cwd(), extendsFileName);
            if (relativeToSandbox.startsWith('..')) {
                config.extends = this.join('..', '..', extend);
                return true;
            }
            else {
                await this.rewriteTSConfigFile(extendsFileName);
            }
        }
        return false;
    }
    async rewriteProjectReferences(config, originTSConfigFileName) {
        const ts = await Promise.resolve().then(() => tslib_1.__importStar(require('typescript')));
        if (Array.isArray(config.references)) {
            for (const reference of config.references) {
                const referencePath = ts.resolveProjectReferencePath(reference);
                const referencedProjectFileName = path_1.default.resolve(path_1.default.dirname(originTSConfigFileName), referencePath);
                const relativeToProject = path_1.default.relative(process.cwd(), referencedProjectFileName);
                if (relativeToProject.startsWith('..')) {
                    reference.path = this.join('..', '..', referencePath);
                }
                else {
                    await this.rewriteTSConfigFile(referencedProjectFileName);
                }
            }
        }
    }
    join(...pathSegments) {
        return pathSegments.map((segment) => segment.replace(/\\/g, '/')).join('/');
    }
}
exports.TSConfigPreprocessor = TSConfigPreprocessor;
TSConfigPreprocessor.inject = plugin_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options);
//# sourceMappingURL=ts-config-preprocessor.js.map