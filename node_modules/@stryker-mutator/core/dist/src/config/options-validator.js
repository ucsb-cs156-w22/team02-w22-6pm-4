"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.markUnknownOptions = exports.validateOptions = exports.defaultOptions = exports.OptionsValidator = void 0;
const tslib_1 = require("tslib");
const os_1 = tslib_1.__importDefault(require("os"));
const glob_1 = require("glob");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
const errors_1 = require("../errors");
const object_utils_1 = require("../utils/object-utils");
const command_test_runner_1 = require("../test-runner/command-test-runner");
const input_1 = require("../input");
const validation_errors_1 = require("./validation-errors");
const ajv = new ajv_1.default({ useDefaults: true, allErrors: true, jsPropertySyntax: true, verbose: true, logger: false, strict: false });
class OptionsValidator {
    constructor(schema, log) {
        this.log = log;
        this.validateFn = ajv.compile(schema);
    }
    validate(options) {
        this.removeDeprecatedOptions(options);
        this.schemaValidate(options);
        this.additionalValidation(options);
    }
    removeDeprecatedOptions(rawOptions) {
        if (typeof rawOptions.mutator === 'string') {
            this.log.warn('DEPRECATED. Use of "mutator" as string is no longer needed. You can remove it from your configuration. Stryker now supports mutating of JavaScript and friend files out of the box.');
            delete rawOptions.mutator;
        }
        // @ts-expect-error mutator.name
        if (typeof rawOptions.mutator === 'object' && rawOptions.mutator.name) {
            this.log.warn('DEPRECATED. Use of "mutator.name" is no longer needed. You can remove "mutator.name" from your configuration. Stryker now supports mutating of JavaScript and friend files out of the box.');
            // @ts-expect-error mutator.name
            delete rawOptions.mutator.name;
        }
        if (Object.keys(rawOptions).includes('testFramework')) {
            this.log.warn('DEPRECATED. Use of "testFramework" is no longer needed. You can remove it from your configuration. Your test runner plugin now handles its own test framework integration.');
            delete rawOptions.testFramework;
        }
        if (Array.isArray(rawOptions.transpilers)) {
            const example = rawOptions.transpilers.includes('babel')
                ? 'babel src --out-dir lib'
                : rawOptions.transpilers.includes('typescript')
                    ? 'tsc -b'
                    : rawOptions.transpilers.includes('webpack')
                        ? 'webpack --config webpack.config.js'
                        : 'npm run build';
            this.log.warn(`DEPRECATED. Support for "transpilers" is removed. You can now configure your own "${util_1.propertyPath('buildCommand')}". For example, ${example}.`);
            delete rawOptions.transpilers;
        }
    }
    additionalValidation(options) {
        const additionalErrors = [];
        if (options.thresholds.high < options.thresholds.low) {
            additionalErrors.push('Config option "thresholds.high" should be higher than "thresholds.low".');
        }
        if (options.maxConcurrentTestRunners !== Number.MAX_SAFE_INTEGER) {
            this.log.warn('DEPRECATED. Use of "maxConcurrentTestRunners" is deprecated. Please use "concurrency" instead.');
            if (!options.concurrency && options.maxConcurrentTestRunners < os_1.default.cpus().length - 1) {
                options.concurrency = options.maxConcurrentTestRunners;
            }
        }
        if (command_test_runner_1.CommandTestRunner.is(options.testRunner) && options.testRunnerNodeArgs.length) {
            this.log.warn('Using "testRunnerNodeArgs" together with the "command" test runner is not supported, these arguments will be ignored. You can add your custom arguments by setting the "commandRunner.command" option.');
        }
        options.mutate.forEach((mutateString, index) => {
            const match = input_1.MUTATION_RANGE_REGEX.exec(mutateString);
            if (match) {
                if (glob_1.hasMagic(mutateString)) {
                    additionalErrors.push(`Config option "mutate[${index}]" is invalid. Cannot combine a glob expression with a mutation range in "${mutateString}".`);
                }
                else {
                    const [_, _fileName, mutationRange, startLine, _startColumn, endLine, _endColumn] = match;
                    const start = parseInt(startLine, 10);
                    const end = parseInt(endLine, 10);
                    if (start < 1) {
                        additionalErrors.push(`Config option "mutate[${index}]" is invalid. Mutation range "${mutationRange}" is invalid, line ${start} does not exist (lines start at 1).`);
                    }
                    if (start > end) {
                        additionalErrors.push(`Config option "mutate[${index}]" is invalid. Mutation range "${mutationRange}" is invalid. The "from" line number (${start}) should be less then the "to" line number (${end}).`);
                    }
                }
            }
        });
        additionalErrors.forEach((error) => this.log.error(error));
        this.throwErrorIfNeeded(additionalErrors);
    }
    schemaValidate(options) {
        if (!this.validateFn(options)) {
            const describedErrors = validation_errors_1.describeErrors(this.validateFn.errors);
            describedErrors.forEach((error) => this.log.error(error));
            this.throwErrorIfNeeded(describedErrors);
        }
    }
    throwErrorIfNeeded(errors) {
        if (errors.length > 0) {
            throw new errors_1.ConfigError(errors.length === 1 ? 'Please correct this configuration error and try again.' : 'Please correct these configuration errors and try again.');
        }
    }
}
exports.OptionsValidator = OptionsValidator;
OptionsValidator.inject = plugin_1.tokens(di_1.coreTokens.validationSchema, plugin_1.commonTokens.logger);
function defaultOptions() {
    const options = {};
    const validator = new OptionsValidator(core_1.strykerCoreSchema, util_1.noopLogger);
    validator.validate(options);
    return options;
}
exports.defaultOptions = defaultOptions;
validateOptions.inject = plugin_1.tokens(plugin_1.commonTokens.options, di_1.coreTokens.optionsValidator);
function validateOptions(options, optionsValidator) {
    optionsValidator.validate(options);
    return util_1.deepFreeze(options);
}
exports.validateOptions = validateOptions;
markUnknownOptions.inject = plugin_1.tokens(plugin_1.commonTokens.options, di_1.coreTokens.validationSchema, plugin_1.commonTokens.logger);
function markUnknownOptions(options, schema, log) {
    const OPTIONS_ADDED_BY_STRYKER = ['set', 'configFile', '$schema'];
    if (object_utils_1.isWarningEnabled('unknownOptions', options.warnings)) {
        const schemaKeys = Object.keys(schema.properties);
        const unknownPropertyNames = Object.keys(options)
            .filter((key) => !key.endsWith('_comment'))
            .filter((key) => !OPTIONS_ADDED_BY_STRYKER.includes(key))
            .filter((key) => !schemaKeys.includes(key));
        if (unknownPropertyNames.length) {
            unknownPropertyNames.forEach((unknownPropertyName) => {
                log.warn(`Unknown stryker config option "${unknownPropertyName}".`);
            });
            const p = util_1.PropertyPathBuilder.create().prop('warnings').prop('unknownOptions').build();
            log.warn(`Possible causes:
   * Is it a typo on your end?
   * Did you only write this property as a comment? If so, please postfix it with "_comment".
   * You might be missing a plugin that is supposed to use it. Stryker loaded plugins from: ${JSON.stringify(options.plugins)}
   * The plugin that is using it did not contribute explicit validation. 
   (disable "${p}" to ignore this warning)`);
        }
    }
    return options;
}
exports.markUnknownOptions = markUnknownOptions;
//# sourceMappingURL=options-validator.js.map