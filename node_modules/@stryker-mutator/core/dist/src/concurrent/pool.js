"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pool = exports.createCheckerPool = exports.createTestRunnerPool = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const util_1 = require("@stryker-mutator/util");
const typed_inject_1 = require("typed-inject");
const di_1 = require("../di");
const MAX_CONCURRENT_INIT = 2;
createTestRunnerPool.inject = typed_inject_1.tokens(di_1.coreTokens.testRunnerFactory, di_1.coreTokens.testRunnerConcurrencyTokens);
function createTestRunnerPool(factory, concurrencyToken$) {
    return new Pool(factory, concurrencyToken$);
}
exports.createTestRunnerPool = createTestRunnerPool;
createCheckerPool.inject = typed_inject_1.tokens(di_1.coreTokens.checkerFactory, di_1.coreTokens.checkerConcurrencyTokens);
function createCheckerPool(factory, concurrencyToken$) {
    return new Pool(factory, concurrencyToken$);
}
exports.createCheckerPool = createCheckerPool;
/**
 * Represents a pool of workers. Use `schedule` to schedule work to be executed on the workers.
 * The pool will automatically recycle the workers, but will make sure only one task is executed
 * on one worker at any one time. Creates as many workers as the concurrency tokens allow.
 * Also takes care of the initialing of the workers (with `init()`)
 */
class Pool {
    constructor(factory, concurrencyToken$) {
        this.createdWorkers = [];
        this.isDisposed = false;
        this.worker$ = concurrencyToken$.pipe(operators_1.mergeMap(async () => {
            var _a;
            if (this.isDisposed) {
                return null;
            }
            else {
                const worker = factory();
                this.createdWorkers.push(worker);
                await ((_a = worker.init) === null || _a === void 0 ? void 0 : _a.call(worker));
                return worker;
            }
        }, MAX_CONCURRENT_INIT), operators_1.filter(util_1.notEmpty), 
        // We use share replay here. This way the dry run can use a test runner that is later reused during mutation testing
        // https://www.learnrxjs.io/learn-rxjs/operators/multicasting/sharereplay
        operators_1.shareReplay());
    }
    /**
     * Returns a promise that resolves if all concurrency tokens have resulted in initialized workers.
     * This is optional, workers will get initialized either way.
     */
    async init() {
        await this.worker$.toPromise();
    }
    /**
     * Schedules a task to be executed on workers in the pool. Each input is paired with a worker, which allows async work to be done.
     * @param input$ The inputs to pair up with a worker.
     * @param task The task to execute on each worker
     */
    schedule(input$, task) {
        const recycleBin = new rxjs_1.Subject();
        const worker$ = rxjs_1.merge(recycleBin, this.worker$);
        return rxjs_1.zip(worker$, input$).pipe(operators_1.mergeMap(async ([worker, input]) => {
            const output = await task(worker, input);
            //  Recycles a worker so its re-emitted from the `worker$` observable.
            recycleBin.next(worker);
            return output;
        }), operators_1.tap({ complete: () => recycleBin.complete() }));
    }
    /**
     * Dispose the pool
     */
    async dispose() {
        this.isDisposed = true;
        await Promise.all(this.createdWorkers.map((worker) => { var _a; return (_a = worker.dispose) === null || _a === void 0 ? void 0 : _a.call(worker); }));
    }
}
exports.Pool = Pool;
//# sourceMappingURL=pool.js.map